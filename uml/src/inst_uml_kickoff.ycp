/**
 * Module:	inst_uml_kickoff.ycp
 *
 * Authors:	Arvin Schnell <arvin@suse.de>
 *
 * Purpose:	Do various tasks before starting with uml installation.
 *
 * $Id$
 */
{
    import "UML";
    import "Directory";
    import "Progress";
    import "Report";
    import "Package";
    import "Service";


    textdomain "uml";


    path umlpath = .uml.options;


    /**
     *
     */
    define boolean install_packages () ``{

	if (!Package::InstallAll (["um-host-kernel",
				   "um-host-install-initrd",
				   "uml-utilities",
				   "bridge-utils",
				   "xterm",
				   "xorg-x11"
				   ]))
	{
	    Report::Error (_("Cannot install required packages."));
	    return false;
	}

	return true;
    }


    /**
     *
     */
    define boolean create_user () ``{

	if (!UML::CreateUser())
	{
	    Report::Error (sformat (_("Cannot create UML user %1."),
				    UML::username));
	    return false;
	}

	return true;
    }

    define boolean setXaccess(string user, boolean enable) {
	map echo = (map) SCR::Execute(.target.bash_output, "echo -n $HOME");
	string home = echo["stdout"]:"";

	// check whether .xauth dir exists
	if (SCR::Read(.target.size, home + "/.xauth") < 0)
	{
	    y2milestone(".xauth doesn't exist");

	    // the directory doesn't exist, nothing to disable
	    if (enable == false)
	    {
		return true;
	    }

	    SCR::Execute(.target.mkdir, home + "/.xauth");
	}

	string xexport = (string) SCR::Read(.target.string, home + "/.xauth/export");
	list<string> exports = [];

	if (xexport != nil)
	{
	    exports = splitstring(xexport, "\n");
	}

	// filter out empty lines
//	exports = filter(string e, exports, {return e != "";});

	boolean changed = false;

	if (enable == true)
	{
	    if (!contains(exports, user))
	    {
		exports = add(exports, user);
		changed = true;
	    }
	}
	else if (enable == false)
	{
	    if (contains(exports, UML::username))
	    {
		exports = filter(string e, exports, {
			return e != user;
		    }
		);

		changed = true;
	    }
	}

	// write changes
	if (changed == true && exports != nil)
	{
	    y2milestone("changed exports to: %1", exports);
	    return (boolean) SCR::Write(.target.string, home + "/.xauth/export", mergestring(exports, "\n"));
	}

	return true;
    }

    /**
     *
     */
    define void register_options_file () ``{
        string scr_file = (string)(SCR::Read (.target.tmpdir)) + "/uml_option.scr";
        SCR::Write (.target.string, scr_file,
		    sformat ("%1\n\n`ag_ini(`SysConfigFile(\"%2\"))\n", umlpath,
			     sformat ("/etc/sysconfig/uml/%1.conf", UML::username)));
        SCR::RegisterAgent (umlpath, scr_file);
    }


    /**
     *
     */
    define void unregister_options_file () ``{

	SCR::Write (umlpath, nil);
	SCR::UnregisterAgent (umlpath);

	// The options file must not be owned by the UML user.  Otherwise it
	// would be possible the change it from the UML instance which would
	// be a security hole.
	SCR::Execute (.target.bash, sformat ("/bin/chown root:root /etc/sysconfig/uml/%1.conf",
					     UML::username));
	SCR::Execute (.target.bash, sformat ("/bin/chmod 0644 /etc/sysconfig/uml/%1.conf",
					     UML::username));
    }


    /**
     *
     */
    define void save_options () ``{

	SCR::Write (add (umlpath, "MEMORY"), UML::memory_size);
	SCR::Write (add (umlpath, "NCPUS"), UML::number_of_cpus);

	SCR::Write (add (umlpath, "STARTMODE"), UML::start_mode);

	SCR::Write (add (umlpath, "USERNAME"), UML::username);
	SCR::Write (add (umlpath, "HOMEDIR"), UML::homedir);

	SCR::Write (add (umlpath, "TAP_DEVICE"), UML::tap_device);
	SCR::Write (add (umlpath, "MAC_ADDRESS"), UML::MAC_address);

	// connect virtual UML ethernet device to real device UML::eth_device
	SCR::Write (add (umlpath, "ETH_DEVICE"), UML::eth_device);

	SCR::Write (add (umlpath, "EXTRA_ARGS"), UML::extra_args);

    }


    /**
     *
     */
    define boolean make_disks () ``{

	SCR::Write (add (umlpath, "NDISKS"), size (UML::disks));

	integer i = 0;
	boolean ret = true;
	foreach (map<string,any> m, UML::disks, ``{

	    integer s = m["size"]:0;

	    string disk_file = sformat ("ubd%1", i);

	    SCR::Write (add (umlpath, sformat ("DISK%1", i)), disk_file);

	    string dd_options = (m["sparse"]:false) ? (" bs=1 count=1 " + sformat ("seek=%1M",s)) : (" bs=1M " + sformat ("count=%1", s));

	    string cmd = "/bin/dd if=/dev/zero of=" + UML::homedir + "/" +
		disk_file + dd_options;

	    y2debug("dd command: %1", cmd);
	    integer result = (integer) SCR::Execute (.target.bash, cmd);

	    if (result != 0)
	    {
		// dd failed, maybe no space left on disk?
		// try to remove failed image if it exists
		SCR::Execute (.target.bash, "rm " + UML::homedir + "/" + disk_file);
		ret = false;
	    }
	    else
	    {
		SCR::Execute (.target.bash, sformat ("/bin/chown %1:users %2/%3",
						     UML::username, UML::homedir,
						     disk_file));
		SCR::Execute (.target.bash, sformat ("/bin/chmod 0600 %1/%2",
						     UML::homedir, disk_file));
	    }

	    i = i + 1;

	});

	return ret;
    }


    /**
     *
     */
    define boolean copy_files () ``{

	y2debug("copy_files() has been started");

	list <string> files_kernel = Pkg::PkgGetFilelist ("um-host-kernel",
							  `installed);
	list <string> files_initrd = Pkg::PkgGetFilelist ("um-host-install-initrd",
							  `installed);

	y2debug("files_kernel: %1", files_kernel);
	y2debug("files_initrd: %1", files_initrd);

	files_kernel = filter (string s, files_kernel,
			       ``(substring (s, 0, size ("/usr/bin/linux")) ==
				  "/usr/bin/linux"));

	files_initrd = filter (string s, files_initrd,
			       ``(substring (s, 0, size ("/usr/lib/initrd")) ==
				  "/usr/lib/initrd"));

	if (size(files_kernel) == 0)
	{
	    map out = (map) SCR::Execute(.target.bash_output, "/bin/ls /usr/bin/linux*");
	    files_kernel = splitstring(out["stdout"]:"", "\n");
	}

	if (size(files_initrd) == 0)
	{
	    map out = (map) SCR::Execute(.target.bash_output, "/bin/ls /usr/lib/initrd*");
	    files_initrd = splitstring(out["stdout"]:"", "\n");
	}

	y2debug("files_kernel: %1", files_kernel);
	y2debug("files_initrd: %1", files_initrd);

	// use the longest filename (ignore symlinks, they are shorter - don't contain version string)
	integer maxsize = 0;
	string kernel = "";
	foreach(string k, files_kernel, {
		integer ksize = size(k);

		if (ksize > maxsize)
		{
		    kernel = k;
		    maxsize = ksize;
		}
	    }
	);

	maxsize = 0;
	string initrd = "";
	foreach(string i, files_initrd, {
		integer isize = size(i);

		if (isize > maxsize)
		{
		    initrd = i;
		    maxsize = isize;
		}
	    }
	);


	y2milestone ("kernel and initrd %1 %2", kernel, initrd);

	if (kernel == "" || initrd == "")
	{
	    return false;
	}

	SCR::Execute (.target.bash, "/bin/cp " + kernel + " " + UML::homedir +
		      "/linux");

	SCR::Execute (.target.bash, sformat ("/bin/chown %1:users %2/linux",
					     UML::username, UML::homedir));
	SCR::Execute (.target.bash, sformat ("/bin/chmod 0700 %1/linux",
					     UML::homedir));

	SCR::Write (add (umlpath, "KERNEL"), "linux");

	SCR::Execute (.target.bash, "/bin/cp " + initrd + " " + UML::homedir +
		      "/initrd");

	SCR::Execute (.target.bash, sformat ("/bin/chown %1:users %2/initrd",
					     UML::username, UML::homedir));
	SCR::Execute (.target.bash, sformat ("/bin/chmod 0600 %1/initrd",
					     UML::homedir));

	SCR::Write (add (umlpath, "INITRD"), "initrd");

	// flush changes
	SCR::Write(umlpath, nil);

	y2debug("copy_files has finished");

	return true;
    };

    /**
     * Parse uml_mconsole /proc/mounts output, return device which is mounted to /mnt directory
     * @param stdout output from uml_mconsole
     * @return string device name or empty string when /mnt entry was not found
     */
    define string FindRootDevice(string stdout)
    {
	string ret = "";

	// remove "OK " message from the beginning if it's present
	if (substring(stdout, 0, 3) == "OK ")
	{
	    stdout = substring(stdout, 3);
	}

	list<string> mounts = splitstring(stdout, "\n");

	foreach(string mount, mounts, ``{
		// get device name and mount point
		list<string> parts = splitstring(mount, " ");

		if (parts[1]:"" == "/mnt")
		{
		    ret = parts[0]:"";
		}
	    }
	);

	return ret;
    }

    /**
     * Write ROOT_DEVICE variable into sysconfig file
     * @param root_device ROOT_DEVICE value
     */
    define void WriteRootDevice(string root_device)
    {
	register_options_file();
	SCR::Write(add(umlpath, "ROOT_DEVICE"), root_device);
	unregister_options_file();
    }

    /**
     *
     */
    define void start_uml (string uml_command) ``{

	string url = "";

	if (UML::inst_type == `configured)
	{
	    map general_data = Pkg::SourceGeneralData (UML::source_id);
	    url = general_data["url"]:"";
	}
	else if (UML::inst_type == `custom)
	{
	    url = UML::custom_source;
	}
	else if (UML::inst_type == `slp)
	{
	    url = "slp://";
	}

	y2milestone("Starting first installation stage (%1)...", uml_command + " install=" + url);
	SCR::Execute (.target.bash, uml_command + " install=" + url);

	map out = (map) SCR::Execute(.target.bash_output, sformat("/bin/grep \" / \" %1 | /usr/bin/cut -f 1 -d \" \"",  UML::homedir + "/mtab"));
	string root_device = "";

	if (out["exit"]:-1 == 0 )
	{
	     root_device = (string) (out["stdout"]:"");
	     list<string> root_dev_list = splitstring(root_device, "\n");
	     root_device = root_dev_list[0]:"";
	}

	y2milestone("UML root device: %1", root_device);

	// write detected root device to sysconfig file
	WriteRootDevice(root_device);
    }


    define void start_uml_2ndstage(string uml_command) {
	string file_name = UML::homedir + "/initrd.inst";

	// check existence of renamed original initrd file - if it
	// doesn't exists then do not start second stage - installation
	// probably failed or was aborted
	integer sz = (integer)SCR::Read(.target.size, file_name);

	if (sz > 0)
	{
	    y2milestone("Starting second installation stage...");

	    // add empty install command
	    SCR::Execute (.target.bash, uml_command + " install=");
	}
	else
	{
	    Report::Error(_("UML installation failed or was aborted."));
	}
    }

    define boolean set_tun_permissions() ``{
	boolean ret = false;

	// set "tun" group
	string command = "/bin/chgrp tun /dev/net/tun";
	ret = (SCR::Execute(.target.bash, command) == 0);

	if (ret == true)
	{
	    // set RW access to device /dev/net/tun for group
	    command = "/bin/chmod g+rw /dev/net/tun";
	    ret = (SCR::Execute(.target.bash, command) == 0);
	}

	return ret;
    }

    /**
     * Enable uml service if start mode is "onboot"
     */
    define boolean enable_uml_service() ``{
	if (UML::start_mode == "onboot")
	{
	    boolean ret = Service::Finetune("uml", ["3", "5"]);
	    if (ret == false)
	    {
		Report::Warning(_("Enabling service 'uml' failed."));
	    }
	}

	return true;
    }


    list <string> progress_stages = [
				     // progress stages
				     _("Install packages"),
				     // progress stages
				     _("Create user"),
				     // progress stages
				     _("Save options"),
				     // progress stages
				     _("Create virtual disks"),
				     // progress stages
				     _("Copy kernel and initrd"),
				     // progress stages
				     _("Start UML installation"),
				     // progress stages
				     _("Finish UML installation")
    ];

    list progress_descriptions = [];

    integer progress_length = size(progress_stages);

    // Headline for UML Installation
    string headline = _("Preparing UML Installation");

    // help text
    string help_text = _("<P><B>Installation</B></P><P>Preparing UML virtual machine for installation...</P>");

    // enable progress
    Progress::on();

    // Headline for UML Installation
    Progress::New (headline, "", progress_length,
		   progress_stages, progress_descriptions, help_text);

    Progress::NextStage ();

    if (install_packages() == false)
    {
	return `abort;
    }

    Progress::NextStage ();

    if (create_user () == false)
    {
	return `abort;
    }

    set_tun_permissions();

    Progress::NextStage ();

    register_options_file ();
    save_options ();
    enable_uml_service();

    Progress::NextStage ();

    if (make_disks() == false)
    {
	// popup error message
	Report::Error(_("An error occurred while creating the disk image."));
	return `abort;
    }

    Progress::NextStage ();

    copy_files ();

    unregister_options_file ();

    // enable X access
    setXaccess(UML::username, true);

    Progress::NextStage ();

    string uml_command = "cd " + UML::homedir + " ; " +
	Directory::ybindir + "/start-uml " +
	"/etc/sysconfig/uml/" + UML::username + ".conf";

    start_uml (uml_command);

    Progress::NextStage ();

    start_uml_2ndstage(uml_command);

    // disable X access - restore previous state
    setXaccess(UML::username, true);

    Progress::Finish ();

    return `next;
}
